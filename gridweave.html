<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flowing Halftone SVG Generator v3</title>
  <style>
    /* Base styles remain similar */
    body { font-family: system-ui, -apple-system, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; } /* Increased max-width slightly */
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
    .image-preview { margin: 20px 0; border: 1px solid #ddd; max-width: 100%; background: #fff; padding: 10px; box-sizing: border-box; min-height: 100px; text-align: center; }
    img#previewImage { max-width: 100%; max-height: 300px; height: auto; display: block; margin: 0 auto; }
    .svg-preview-area { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; }
    .svg-preview { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px; }
    .svg-container { background: white; padding: 15px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); flex: 1 1 250px; min-width: 250px; box-sizing: border-box; text-align: center; border: 1px solid #eee; }
    .svg-container h3 { margin-top: 0; font-size: 1em; color: #444; }
    .svg-container svg { max-width: 100%; height: auto; border: 1px solid #eee; background: repeating-conic-gradient(#f0f0f0 0% 25%, transparent 0% 50%) 50% / 10px 10px; }
    .download-links { margin-top: 20px; padding: 15px; background: #e9e9e9; border-radius: 4px; text-align: center; }
    .download-links a { display: inline-block; margin: 5px; padding: 8px 15px; background: #555; color: white; text-decoration: none; border-radius: 4px; }
    .download-links a:hover { background: #333; }

    /* Input styling */
    button, select, input[type="text"], input[type="number"], input[type="file"], input[type="color"] { padding: 8px 12px; margin: 0; /* Remove default margin */ border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; vertical-align: middle; font-size: 0.9em;}
    input[type="number"] { width: 70px; /* Give number inputs a consistent width */ text-align: right; padding-right: 5px;}
    input[type="color"] { padding: 2px; height: 38px; width: 50px; border: 1px solid #ccc; vertical-align: middle; }
    input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
    input[type="range"] { vertical-align: middle; width: calc(100% - 85px); /* Adjust width to fit next to number input */}
    input:disabled, button:disabled { background: #eee; cursor: not-allowed; color: #999 }
    button { background: #0066ff; color: white; border: none; cursor: pointer; padding: 10px 15px; }

    /* Control layout */
    label { margin: 0; font-weight: bold; font-size: 0.9em; vertical-align: middle; display: block; /* Make labels block by default */ margin-bottom: 5px;}
    .controls-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Slightly wider min */ gap: 20px; margin-top: 15px; }
    .control-group { background: #f9f9f9; padding: 15px; border-radius: 5px; border: 1px solid #eee; }
    .control-group label:not(:first-child) { margin-top: 12px; /* Space between controls */}
    .control-row { /* Base row style */ display: flex; align-items: center; flex-wrap: nowrap; /* Prevent slider/input wrapping initially */ gap: 10px; margin-bottom: 10px; }
    .control-row label { display: inline-block !important; margin-bottom: 0; flex-shrink: 0;} /* Override block for rows */

    /* Specific row styles */
    .slider-input-row label { flex-basis: 150px; /* Consistent label width for sliders */ text-align: right; padding-right: 5px;}
    .slider-input-row input[type="range"] { flex-grow: 1; width: auto; /* Allow range to fill space */}
    .slider-input-row input[type="number"] { flex-shrink: 0; }

    /* Color Picker Alignment Fix */
    .color-row { justify-content: flex-start; /* Align items left */ }
    .color-row label { flex-basis: 100px; /* Fixed width */ text-align: right; }
    .color-row input[type="color"] { flex-shrink: 0; }

    /* Checkbox alignment */
    .checkbox-row label { display: flex !important; align-items: center; flex-basis: auto;} /* Let label size naturally */

    .status-message { font-style: italic; color: #666; margin: 10px 0; font-size: 0.9em;}

  </style>
</head>
<body>
  <h1>Flowing Halftone SVG Generator v3</h1>

  <div class="controls">
    <div class="control-row">
        <label for="imageInput">Upload Image:</label>
        <input type="file" id="imageInput" accept="image/*">
        <span id="imageStatus" class="status-message"></span>
    </div>

    <div class="controls-grid">
        <div class="control-group">
             <label for="outputWidthMM">Output Width (mm):</label>
             <input type="number" id="outputWidthMM" value="210" min="10" step="1">

             <label for="densityCm">Density (Circles/cm):</label>
             <div class="control-row slider-input-row">
                <input type="range" id="densityCmRange" min="1" max="20" value="6" step="0.5">
                <input type="number" id="densityCm" min="1" max="20" value="6" step="0.1">
             </div>

             <label for="maxCircleSize">Max Diameter (px):</label>
              <div class="control-row slider-input-row">
                  <input type="range" id="maxCircleSizeRange" min="1" max="50" value="9" step="0.5">
                  <input type="number" id="maxCircleSize" min="1" max="50" value="9" step="0.1">
              </div>

             <label for="minCircleSize">Min Diameter (px):</label>
             <div class="control-row slider-input-row">
                 <input type="range" id="minCircleSizeRange" min="0.1" max="10" value="0.5" step="0.1">
                  <input type="number" id="minCircleSize" min="0.1" max="10" value="0.5" step="0.1">
             </div>
        </div>

        <div class="control-group">
             <label for="offsetX">Offset Grid X (px):</label>
            <div class="control-row slider-input-row">
                <input type="range" id="offsetXRange" min="-30" max="30" value="5" step="1">
                <input type="number" id="offsetX" min="-30" max="30" value="5" step="1">
            </div>

            <label for="offsetY">Offset Grid Y (px):</label>
             <div class="control-row slider-input-row">
                 <input type="range" id="offsetYRange" min="-30" max="30" value="5" step="1">
                 <input type="number" id="offsetY" min="-30" max="30" value="5" step="1">
             </div>

             <div class="control-row checkbox-row">
                <label for="invertOffsetSize">
                    <input type="checkbox" id="invertOffsetSize"> Invert Offset Size
                </label>
            </div>
             <hr style="margin: 15px 0; border: none; border-top: 1px solid #eee;">
             <div class="control-row checkbox-row">
                 <label for="useGradientDistortion">
                     <input type="checkbox" id="useGradientDistortion" disabled> Use Image-Based Flow
                 </label>
             </div>
             <label for="distortionAmount">Distortion Amount (px):</label>
             <div class="control-row slider-input-row">
                 <input type="range" id="distortionAmountRange" min="0" max="50" value="10" step="1">
                  <input type="number" id="distortionAmount" min="0" max="50" value="10" step="1">
             </div>

             <label for="distortionScale">Wave Scale:</label>
             <div class="control-row slider-input-row">
                 <input type="range" id="distortionScaleRange" min="0.001" max="0.1" value="0.015" step="0.001">
                 <input type="number" id="distortionScale" min="0.001" max="0.1" value="0.015" step="0.001">
             </div>
             <span class="status-message">(Wave Scale only used if Image-Based Flow is off)</span>
        </div>

        <div class="control-group">
            <div class="control-row color-row"> <label for="mainColor1">Main Color 1:</label>
                 <input type="color" id="mainColor1" value="#FFFF00">
            </div>
             <div class="control-row color-row"> <label for="mainColor2">Main Color 2:</label>
                 <input type="color" id="mainColor2" value="#0000FF">
            </div>
            <div class="control-row color-row"> <label for="offsetColor">Offset Color:</label>
                 <input type="color" id="offsetColor" value="#800080">
            </div>
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #eee;">
            <div class="control-row checkbox-row">
                <label for="useStroke"> <input type="checkbox" id="useStroke"> Use Outlines (Strokes) </label>
            </div>
             <div class="control-row slider-input-row"> <label for="strokeWidth">Stroke Width (px):</label>
                <input type="number" id="strokeWidth" min="0.1" max="10" value="0.5" step="0.1" disabled>
            </div>
        </div>
    </div>

     <div class="image-preview" id="imagePreview">
        <p>Upload an image to begin.</p>
        <img id="previewImage" src="#" alt="Image Preview" style="display: none;">
    </div>

    <div style="text-align: center; margin-top: 20px;">
        <button id="generateButton" disabled>Generate SVGs</button>
    </div>

  </div> <div class="svg-preview-area">
         <h2>SVG Previews</h2>
         <div class="svg-preview" id="svgPreview"> <p>Previews will appear here after generation.</p> </div>
         <div class="download-links" id="downloadLinks"> </div>
    </div>

  <script>
    // --- Configuration ---
    const config = { /* Populated in initialize() */ };

    // --- Constants ---
    const MM_PER_INCH = 25.4;
    const DPI = 96; // Assumed screen DPI for pixel-mm baseline
    const MM_PER_PIXEL = MM_PER_INCH / DPI;

    // --- DOM elements ---
    const imageInput = document.getElementById('imageInput');
    const imageStatus = document.getElementById('imageStatus');
    const imagePreviewDiv = document.getElementById('imagePreview');
    const previewImage = document.getElementById('previewImage');
    const generateButton = document.getElementById('generateButton');
    const svgPreview = document.getElementById('svgPreview');
    const downloadLinks = document.getElementById('downloadLinks');
    // Inputs
    const outputWidthMMInput = document.getElementById('outputWidthMM');
    const densityCmRange = document.getElementById('densityCmRange'); // New ID for range
    const densityCmInput = document.getElementById('densityCm');       // New ID for number
    const maxCircleSizeRange = document.getElementById('maxCircleSizeRange');
    const maxCircleSizeInput = document.getElementById('maxCircleSize');
    const minCircleSizeRange = document.getElementById('minCircleSizeRange');
    const minCircleSizeInput = document.getElementById('minCircleSize');
    const offsetXRange = document.getElementById('offsetXRange');
    const offsetXInput = document.getElementById('offsetX');
    const offsetYRange = document.getElementById('offsetYRange');
    const offsetYInput = document.getElementById('offsetY');
    const invertOffsetSizeInput = document.getElementById('invertOffsetSize');
    const useGradientDistortionInput = document.getElementById('useGradientDistortion');
    const distortionAmountRange = document.getElementById('distortionAmountRange');
    const distortionAmountInput = document.getElementById('distortionAmount');
    const distortionScaleRange = document.getElementById('distortionScaleRange'); // Wave scale
    const distortionScaleInput = document.getElementById('distortionScale');
    const mainColor1Input = document.getElementById('mainColor1');
    const mainColor2Input = document.getElementById('mainColor2');
    const offsetColorInput = document.getElementById('offsetColor');
    const useStrokeInput = document.getElementById('useStroke');
    const strokeWidthInput = document.getElementById('strokeWidth'); // Only number input for now

    // --- Global State ---
    let currentImage = null;
    let imagePixelData = null;
    let currentGradientData = null;
    let imageWidth = 0;
    let imageHeight = 0;

    // --- Helper Functions --- (Keep all helpers: getBrightness, calculateGradientField, mapRange, distortPointWave, distortPointGradient, distortPoint, createSVGHeader, createSVGGroup, createCircleSVG)
    // ... (These functions remain unchanged from the previous version) ...
    function getBrightness(imageData, x, y, width) { x = Math.max(0, Math.min(Math.floor(x), width - 1)); y = Math.max(0, Math.min(Math.floor(y), imageData.height - 1)); const i = (y * width + x) * 4; if (i >= 0 && i < imageData.data.length - 3) return imageData.data[i]; return 255;}
    function calculateGradientField(imageData, width, height) { console.time("Gradient Calculation"); const data = imageData.data; const gradientField = new Array(width * height); let maxMagnitude = 0; for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const idx = (y * width + x); const bL = getBrightness(imageData, x - 1, y, width); const bR = getBrightness(imageData, x + 1, y, width); const bT = getBrightness(imageData, x, y - 1, width); const bB = getBrightness(imageData, x, y + 1, width); const gx = (bR - bL) / 2; const gy = (bB - bT) / 2; const mag = Math.sqrt(gx * gx + gy * gy); gradientField[idx] = { gx, gy, mag }; if (mag > maxMagnitude) { maxMagnitude = mag; } } } console.timeEnd("Gradient Calculation"); console.log("Max gradient magnitude:", maxMagnitude); return { field: gradientField, maxMagnitude: maxMagnitude > 0 ? maxMagnitude : 1 }; }
    function mapRange(value, fromLow, fromHigh, toLow, toHigh) { const clampedValue = Math.max(fromLow, Math.min(value, fromHigh)); const result = toLow + (toHigh - toLow) * ((clampedValue - fromLow) / (fromHigh - fromLow)); return isNaN(result) ? toLow : result; }
    function distortPointWave(x, y, width, height, amount, scale) { const xWave = Math.sin(y * scale) * amount; const yWave = Math.cos(x * scale) * amount; const variationX = Math.sin(x * y * 0.0001) * (amount * 0.1); const variationY = Math.cos(x * y * 0.00015) * (amount * 0.1); return { x: x + xWave + variationX, y: y + yWave + variationY }; }
    function distortPointGradient(x, y, width, height, amount, gradientData) { if (!gradientData || !gradientData.field) return {x, y}; const idx = Math.floor(y) * width + Math.floor(x); const grad = gradientData.field[idx]; if (grad && grad.mag > 0.1) { let dx = -grad.gy; let dy = grad.gx; const len = Math.sqrt(dx * dx + dy * dy); if (len > 0) { dx /= len; dy /= len; } const displacementMagnitude = mapRange(grad.mag, 0, gradientData.maxMagnitude, 0, amount); return { x: x + dx * displacementMagnitude, y: y + dy * displacementMagnitude }; } return { x: x, y: y }; }
    function distortPoint(x, y, width, height) { if (config.useGradientDistortion && currentGradientData) { return distortPointGradient(x, y, width, height, config.distortionAmount, currentGradientData); } else { config.distortionScale = parseFloat(distortionScaleInput.value) || 0.015; return distortPointWave(x, y, width, height, config.distortionAmount, config.distortionScale); } }
    function createSVGHeader(pixelWidth, pixelHeight, mmWidth, mmHeight) { const w = mmWidth.toFixed(2); const h = mmHeight.toFixed(2); return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${pixelWidth} ${pixelHeight}" width="${w}mm" height="${h}mm" shape-rendering="geometricPrecision">`; }
    function createSVGGroup(color, useStroke, strokeWidth) { if (useStroke) return `<g fill="none" stroke="${color}" stroke-width="${strokeWidth}">`; else return `<g fill="${color}" stroke="none">`; }
    function createCircleSVG(cx, cy, r) { if (r && r > 0.05) return `<circle cx="${cx.toFixed(3)}" cy="${cy.toFixed(3)}" r="${r.toFixed(3)}" />`; return ""; }

    // --- Synchronization for Slider + Number Input ---
    function setupSyncedInput(rangeInput, numberInput, configKey, isFloat = true) {
        const updateConfig = (valueStr) => {
            const value = isFloat ? parseFloat(valueStr) : parseInt(valueStr);
            const min = parseFloat(rangeInput.min);
            const max = parseFloat(rangeInput.max);
            // Clamp value to range limits
            const clampedValue = Math.max(min, Math.min(value, max));
            if (!isNaN(clampedValue)) {
                 config[configKey] = clampedValue;
                 // Update both inputs to reflect potentially clamped value
                 rangeInput.value = clampedValue;
                 numberInput.value = clampedValue;
            } else {
                 // Reset to config value if input is invalid
                 numberInput.value = config[configKey];
            }
            // console.log(`Updated ${configKey}:`, config[configKey]); // Debug
        };

        rangeInput.addEventListener('input', (e) => {
             numberInput.value = e.target.value; // Update number field from slider
             updateConfig(e.target.value);
        });

        numberInput.addEventListener('input', (e) => {
             rangeInput.value = e.target.value; // Update slider from number field
             updateConfig(e.target.value);
        });
         // Update on 'change' too for pasting/etc.
         numberInput.addEventListener('change', (e) => {
             updateConfig(e.target.value);
         });
    }


    // --- Event Listeners ---
    // Setup synchronization for controls
    setupSyncedInput(densityCmRange, densityCmInput, 'densityCm');
    setupSyncedInput(maxCircleSizeRange, maxCircleSizeInput, 'maxCircleSize');
    setupSyncedInput(minCircleSizeRange, minCircleSizeInput, 'minCircleSize');
    setupSyncedInput(offsetXRange, offsetXInput, 'offsetX', false); // Use integers for offset? Or float? Float ok.
    setupSyncedInput(offsetYRange, offsetYInput, 'offsetY', false);
    setupSyncedInput(distortionAmountRange, distortionAmountInput, 'distortionAmount', false);
    setupSyncedInput(distortionScaleRange, distortionScaleInput, 'distortionScale');
    // Stroke width only has number input currently
    strokeWidthInput.addEventListener('input', () => { config.strokeWidth = parseFloat(strokeWidthInput.value) || 0.5; });


    // Other input handlers
    outputWidthMMInput.addEventListener('input', () => { config.outputWidthMM = parseFloat(outputWidthMMInput.value) || 210; });
    mainColor1Input.addEventListener('input', () => { config.mainColor1 = mainColor1Input.value; });
    mainColor2Input.addEventListener('input', () => { config.mainColor2 = mainColor2Input.value; });
    offsetColorInput.addEventListener('input', () => { config.offsetColor = offsetColorInput.value; });
    useStrokeInput.addEventListener('change', () => { config.useStroke = useStrokeInput.checked; strokeWidthInput.disabled = !config.useStroke; });
    useGradientDistortionInput.addEventListener('change', () => { config.useGradientDistortion = useGradientDistortionInput.checked; distortionScaleInput.disabled = config.useGradientDistortion; distortionScaleRange.disabled = config.useGradientDistortion;});
    invertOffsetSizeInput.addEventListener('change', () => { config.invertOffsetSize = invertOffsetSizeInput.checked; });


    imageInput.addEventListener('change', (e) => { /* Same image loading and gradient calculation */
        const file = e.target.files[0];
        currentImage = null; imagePixelData = null; currentGradientData = null;
        generateButton.disabled = true; useGradientDistortionInput.checked = false;
        useGradientDistortionInput.disabled = true; config.useGradientDistortion = false;
        distortionScaleInput.disabled = false; distortionScaleRange.disabled = false;
        imageStatus.textContent = ""; previewImage.style.display = 'none';
        imagePreviewDiv.querySelector('p').style.display = 'block';

        if (file) {
            imageStatus.textContent = "Loading image...";
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    imageStatus.textContent = "Processing image...";
                    currentImage = img; imageWidth = img.width; imageHeight = img.height;
                    previewImage.src = event.target.result; previewImage.style.display = 'block';
                    imagePreviewDiv.querySelector('p').style.display = 'none';
                    setTimeout(() => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        canvas.width = imageWidth; canvas.height = imageHeight;
                        ctx.filter = 'grayscale(100%)'; ctx.drawImage(img, 0, 0, imageWidth, imageHeight);
                        try {
                            imagePixelData = ctx.getImageData(0, 0, imageWidth, imageHeight);
                            imageStatus.textContent = "Calculating flow field...";
                            setTimeout(() => {
                                try {
                                    currentGradientData = calculateGradientField(imagePixelData, imageWidth, imageHeight);
                                    generateButton.disabled = false; useGradientDistortionInput.disabled = false;
                                    imageStatus.textContent = "Image ready."; console.log("Image and gradient data ready.");
                                } catch (gradientError) { console.error("Error calculating gradient field:", gradientError); alert("Could not calculate image flow field. Using wave distortion only."); imageStatus.textContent = "Image loaded (gradient failed)."; generateButton.disabled = false; useGradientDistortionInput.disabled = true; }
                            }, 10);
                        } catch (error) { console.error("Error getting image data:", error); alert("Could not process image. Check console."); imageStatus.textContent = "Image processing failed."; }
                    }, 10);
                };
                img.onerror = () => { alert("Failed to load image."); imageStatus.textContent = "Failed to load image."; }
                img.src = event.target.result;
            };
            reader.onerror = () => { alert("Failed to read file."); imageStatus.textContent = "Failed to read file."; }
            reader.readAsDataURL(file);
        }
     });

    // --- Main Generation Logic ---
    generateButton.addEventListener('click', () => { /* Update config read */
      if (!currentImage || !imagePixelData) { alert("Please upload image."); return; }
      if (config.useGradientDistortion && !currentGradientData) { alert("Gradient data not ready..."); return; }

      // Update config from inputs just before generation
      config.outputWidthMM = parseFloat(outputWidthMMInput.value) || 210;
      config.densityCm = parseFloat(densityCmInput.value) || 6; // Read from number input
      config.maxCircleSize = parseFloat(maxCircleSizeInput.value) || 9;
      config.minCircleSize = parseFloat(minCircleSizeInput.value) || 0.5;
      config.offsetX = parseFloat(offsetXInput.value) || 5;
      config.offsetY = parseFloat(offsetYInput.value) || 5;
      config.invertOffsetSize = invertOffsetSizeInput.checked;
      config.useGradientDistortion = useGradientDistortionInput.checked;
      config.distortionAmount = parseFloat(distortionAmountInput.value) || 10;
      if (!config.useGradientDistortion) { config.distortionScale = parseFloat(distortionScaleInput.value) || 0.015; }
      config.mainColor1 = mainColor1Input.value;
      config.mainColor2 = mainColor2Input.value;
      config.offsetColor = offsetColorInput.value;
      config.useStroke = useStrokeInput.checked;
      config.strokeWidth = parseFloat(strokeWidthInput.value) || 0.5;

      generateButton.textContent = "Generating..."; generateButton.disabled = true;
      svgPreview.innerHTML = '<p>Generating SVG layers...</p>'; downloadLinks.innerHTML = '';

      setTimeout(() => {
          try { const results = generateSVGs(); displayResults(results); }
          catch (error) { console.error("Error during SVG generation:", error); alert("An error occurred during SVG generation. Check console."); svgPreview.innerHTML = '<p>Error generating SVGs.</p>'; }
          finally { generateButton.textContent = "Generate SVGs"; generateButton.disabled = !(currentImage && imagePixelData && (!config.useGradientDistortion || currentGradientData)); }
      }, 10);
    });


    function generateSVGs() { // ** UPDATED for Density -> Spacing **
      if (!imagePixelData) throw new Error("Image pixel data missing.");
      if (config.useGradientDistortion && !currentGradientData) throw new Error("Gradient data missing for gradient distortion.");

      console.log("Starting SVG generation with config:", config);

      // --- Calculate actual grid spacing in Pixels from Density ---
      let actualGridSpacingPx = 10; // Default fallback
      if (config.densityCm > 0 && config.outputWidthMM > 0 && imageWidth > 0) {
          const densityMM = config.densityCm / 10; // Circles per mm
          const numCirclesAcrossOutput = densityMM * config.outputWidthMM;
          actualGridSpacingPx = imageWidth / numCirclesAcrossOutput;
          if (actualGridSpacingPx < 1) actualGridSpacingPx = 1; // Avoid extreme density
          console.log(`Density ${config.densityCm} circ/cm -> Spacing ${actualGridSpacingPx.toFixed(2)} px`);
      } else {
          console.warn("Could not calculate spacing from density, using fallback.");
      }
      // ---

      const aspect = imageWidth / imageHeight;
      const outputWidthMM = config.outputWidthMM;
      const outputHeightMM = outputWidthMM / aspect;

      const group1Def = createSVGGroup(config.mainColor1, config.useStroke, config.strokeWidth);
      const group2Def = createSVGGroup(config.mainColor2, config.useStroke, config.strokeWidth);
      const groupOffsetDef = createSVGGroup(config.offsetColor, config.useStroke, config.strokeWidth);

      let circles1 = ""; let circles2 = ""; let circlesOffset = "";

      // Use calculated spacing in loops
      for (let y = 0; y < imageHeight; y += actualGridSpacingPx) {
        for (let x = 0; x < imageWidth; x += actualGridSpacingPx) {
          const mainDistorted = distortPoint(x, y, imageWidth, imageHeight);
          const mainBrightness = getBrightness(imagePixelData, x, y, imageWidth);
          const mainDiameter = mapRange(mainBrightness, 0, 255, config.maxCircleSize, config.minCircleSize);

          // Add BOTH main circles
          circles1 += createCircleSVG(mainDistorted.x, mainDistorted.y, mainDiameter / 2);
          circles2 += createCircleSVG(mainDistorted.x, mainDistorted.y, mainDiameter / 2);

          // Offset Grid
          const offsetBaseX = x + config.offsetX;
          const offsetBaseY = y + config.offsetY;
          const offsetDistorted = distortPoint(offsetBaseX, offsetBaseY, imageWidth, imageHeight);
          const offsetBrightness = getBrightness(imagePixelData, x, y, imageWidth);
          let offsetDiameter;
          if (config.invertOffsetSize) {
              offsetDiameter = mapRange(offsetBrightness, 0, 255, config.minCircleSize, config.maxCircleSize);
          } else {
              offsetDiameter = mapRange(offsetBrightness, 0, 255, config.maxCircleSize, config.minCircleSize);
          }
          circlesOffset += createCircleSVG(offsetDistorted.x, offsetDistorted.y, offsetDiameter / 2);
        }
      }

      // Assemble SVGs (remains same)
      const finalSVGs = {};
      const header = createSVGHeader(imageWidth, imageHeight, outputWidthMM, outputHeightMM);
      finalSVGs[config.mainColor1] = header + group1Def + circles1 + '</g></svg>';
      finalSVGs[config.mainColor2] = header + group2Def + circles2 + '</g></svg>';
      finalSVGs[config.offsetColor] = header + groupOffsetDef + circlesOffset + '</g></svg>';
      const combinedSvgString = header + group1Def + circles1 + '</g>' + group2Def + circles2 + '</g>' + groupOffsetDef + circlesOffset + '</g>' + '</svg>';

      console.log("SVG generation complete.");
      return { individual: finalSVGs, combined: combinedSvgString };
    }

    function displayResults(results) { /* Remains the same */ }
    // ... (displayResults function code remains unchanged) ...
    function displayResults(results) { svgPreview.innerHTML = ''; downloadLinks.innerHTML = ''; const { individual, combined } = results; let layerIndex = 1; Object.entries(individual).forEach(([color, svgString]) => { if (!svgString) return; const container = document.createElement('div'); container.className = 'svg-container'; const title = `Layer ${layerIndex++}: ${color}`; container.innerHTML = `<h3>${title}</h3>` + svgString; svgPreview.appendChild(container); try { const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `halftone-layer-${layerIndex-1}-${color}.svg`; link.textContent = `Download ${title}`; downloadLinks.appendChild(link); } catch (error) { console.error("Error creating download link for", color, error); } }); if (combined) { const container = document.createElement('div'); container.className = 'svg-container'; container.innerHTML = `<h3>Combined Preview</h3>` + combined; svgPreview.appendChild(container); try { const blob = new Blob([combined], { type: 'image/svg+xml;charset=utf-8' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `halftone-combined.svg`; link.textContent = `Download Combined SVG`; downloadLinks.appendChild(link); } catch (error) { console.error("Error creating download link for combined SVG:", error); } } }


    // --- Initial Setup ---
    function initialize() {
        // Populate config with initial default values from HTML
        config.outputWidthMM = parseFloat(outputWidthMMInput.value) || 210;
        config.densityCm = parseFloat(densityCmInput.value) || 6; // Read density input
        config.maxCircleSize = parseFloat(maxCircleSizeInput.value) || 9;
        config.minCircleSize = parseFloat(minCircleSizeInput.value) || 0.5;
        config.offsetX = parseFloat(offsetXInput.value) || 5;
        config.offsetY = parseFloat(offsetYInput.value) || 5;
        config.invertOffsetSize = invertOffsetSizeInput.checked || false;
        config.useGradientDistortion = useGradientDistortionInput.checked || false;
        config.distortionAmount = parseFloat(distortionAmountInput.value) || 10;
        config.distortionScale = parseFloat(distortionScaleInput.value) || 0.015;
        config.mainColor1 = mainColor1Input.value || '#FFFF00';
        config.mainColor2 = mainColor2Input.value || '#0000FF';
        config.offsetColor = offsetColorInput.value || '#800080';
        config.useStroke = useStrokeInput.checked || false;
        config.strokeWidth = parseFloat(strokeWidthInput.value) || 0.5;

        // Set initial visual state for inputs
        densityCmRange.value = config.densityCm;
        maxCircleSizeRange.value = config.maxCircleSize;
        minCircleSizeRange.value = config.minCircleSize;
        offsetXRange.value = config.offsetX;
        offsetYRange.value = config.offsetY;
        distortionAmountRange.value = config.distortionAmount;
        distortionScaleRange.value = config.distortionScale;

        strokeWidthInput.disabled = !config.useStroke;
        useGradientDistortionInput.disabled = true;
        distortionScaleInput.disabled = config.useGradientDistortion;
        distortionScaleRange.disabled = config.useGradientDistortion;
        invertOffsetSizeInput.checked = config.invertOffsetSize;

        // Setup sync listeners AFTER setting initial values
        setupSyncedInput(densityCmRange, densityCmInput, 'densityCm');
        setupSyncedInput(maxCircleSizeRange, maxCircleSizeInput, 'maxCircleSize');
        setupSyncedInput(minCircleSizeRange, minCircleSizeInput, 'minCircleSize');
        setupSyncedInput(offsetXRange, offsetXInput, 'offsetX');
        setupSyncedInput(offsetYRange, offsetYInput, 'offsetY');
        setupSyncedInput(distortionAmountRange, distortionAmountInput, 'distortionAmount');
        setupSyncedInput(distortionScaleRange, distortionScaleInput, 'distortionScale');


        console.log("Generator initialized.");
    }

    initialize();

  </script>
</body>
</html>
